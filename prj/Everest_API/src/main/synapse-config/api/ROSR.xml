<?xml version="1.0" encoding="UTF-8"?>
<api context="/everest" name="RORS" xmlns="http://ws.apache.org/ns/synapse">
    <resource methods="POST" url-mapping="/ROs">
        <inSequence>
            <!-- get the name of the first element child of  the context root. -->
            <!--
	                                        create the xml body:
	                                        a. get and put in the variable "url" the text node of the only element under the context root "$ctx:BODY_FOR_RESOURCES//external", that is array item of the field "external" corresponding to the current iteration (getFirstElement would do get this element because it is the only element)
	                                        b. create an xml string "proxy" with an xml template where the "url" variable value is substituted with the sintax {url}
	                                        c. set the http request body with the value of the variable "proxy" through setPayloadXML
	                                        -->
            <enrich>
                <source clone="true" type="body"/>
                <target property="BODY_FOR_RESOURCES" type="property"/>
            </enrich>
            <property expression="$trp:Authorization" name="AUTH" scope="default" type="STRING"/>
            <!--++
        				It is expected that the client calls this operation with this request:
        				
						POST /everest/ROs HTTP/1.1
						Host: localhost:8280
						Content-Type: application/json
						Authorization: Bearer 7d6df5f8-6b5c-4d88-95e1-da101dcee6f8
						Slug: cde
						Content-Length: 243
						
						{"ro_title": "The Title", "ro_desc": "The Description", "ro_vrc": "CNR", "internal": [{"myfolder/file1.txt": "MTIz"}, {"myfolder/file2.txt": "NDU2"}],"external": ["http://sdeg.com/resource1.html", "https://sdeg.it/res2.do"], "mode": "PRIVATE"}
						
 						Please note that the value of json fields in the http body are only examples. Read EverestAPI_interface_documentation_<version>.docx for details.
						Using curl the corresponding command would be:
						curl -v http://localhost:8280/everest/ROs -H "Authorization: Bearer 7d6df5f8-6b5c-4d88-95e1-da101dcee6f8" -H "Content-Type: application/json" -H "Slug: cde" -d "{\"ro_title\": \"The Title\", \"ro_desc\": \"The Description\", \"ro_vrc\": \"CNR\", \"internal\": [{\"myfolder/file1.txt\": \"MTIz\"}, {\"myfolder/file2.txt\": \"NDU2\"}],\"external\": [\"http://sdeg.com/resource1.html\", \"https://sdeg.it/res2.do\"], \"mode\": \"PRIVATE\"}"
						
						With this only invocation by the client, various invocations are performed to the rohub backend. Those are:
						1. Creation of the RO with a given name, title, and description
						2. Optional setting public/private visibility mode (access rights)
						3. Optional aggregation of internal resources
						4. Optional aggregation of external resources
						5. Annotate the RO with the title, description, and VRC
        			 -->
            <!-- spawn one more separate thread to aggregate resources (see below for the main thread) -->
            <!--payloadFactory media-type="xml">
                                                <format>
                                                    <ms11:text xmlns:ms11="http://ws.apache.org/commons/ns/payload">MTIz</ms11:text>
                                                </format>
                                                <args/>
                                            </payloadFactory-->
            <log level="custom">
                <property name="mylog" value="***************************** RECEIVED REQUEST **************************"/>
                <property expression="$trp:Authorization" name="auth"/>
                <property expression="$trp:Slug" name="slug"/>
            </log>
            <!--++
            			do the first invocation to the backend:
            			1. Creation of the RO with a given name, title, and description
            			
                        The http request must be this (given the example client request above):
                        
	                        POST /rodl/ROs HTTP/1.1
							Authorization: Bearer 7d6df5f8-6b5c-4d88-95e1-da101dcee6f8
							Accept: */*
							Slug: cde
							Content-Type: application/xml
							Transfer-Encoding: chunked
							Host: sandbox.rohub.org
							Connection: Keep-Alive
							User-Agent: Synapse-PT-HttpComponents-NIO
							
							0
							
							Please note that the http body is empty; all information are contained in the http headers.
							Please also note the synapse and therefore wso2esb works by "deltas": only differences between the outgoing requested and the incoming one are to be set.
                     -->
            <!-- this is needed in order to not block the POST request containing no body -->
            <property name="FORCE_POST_PUT_NOBODY" scope="axis2" type="BOOLEAN" value="true"/>
            <!-- No directive is needed to set Slug and Authorization header parameters because they are exactly equal to those coming from the request  -->
            <!-- next two directives (1.a and 1.b) are needed to empty the body for the next call to rohub: I do not know how to empty a json body, so I transform it in xml -->
            <!-- 1.a: transform the body format from json to xml -->
            <!-- (WSO2ESB) really speaking, here it is creating a new xml property of the mc containing the xml tree of the request body, in addition to the json tree-->
            <property name="messageType" scope="axis2" type="STRING" value="application/xml"/>
            <!-- 1.b: empty the payloadXML of the request through this script-->
            <!-- (WSO2ESB) the deletion of this xml tree does not affect the json object. Indeed the json object unaltered will be used next. (see below) -->
            <script language="js"><![CDATA[mc.getEnvelope().getBody().getFirstElement().detach();]]></script>
            <log level="custom">
                <property name="mylog" value="***************************** CALL: CREATE A NEW RESEARCH OBJECT **************************"/>
            </log>
            <!-- the request has been so synthesized and the back-end can be invoked right now -->
            <call>
                <endpoint>
                    <http uri-template="http://sandbox.rohub.org/rodl/"/>
                </endpoint>
            </call>
            <!-- The expected response is this:

	            HTTP/1.1 201 Created
				Date: Fri, 13 Jan 2017 14:50:55 GMT
				Server: Apache
				Location: http://sandbox.rohub.org/rodl/ROs/cde-20/
				Content-disposition: attachment; filename=".ro/manifest.rdf
				Content-Length: 4354
				Keep-Alive: timeout=200, max=100
				Connection: Keep-Alive
				Content-Type: application/rdf+xml
				
				here the body (that is not needed)
            
             -->
            <!-- save in a property (RONAME) the URI of the just created RO got in the Location http header of the response -->
            <property expression="$trp:Location" name="RONAME" scope="default" type="STRING"/>
            <script language="js"><![CDATA[//
            	var urldecoded = decodeURIComponent( mc.getProperty("RONAME"));
            	mc.setProperty("LOCATION", urldecoded);
            //]]></script>
            <!-- keep on processing if the response status code is what is expected to be in case of correct back end response, that is 201 in this case.
            In the else branch (now missing) exceptional response must be handled properly!
            -->
            <filter regex="201" source="get-property('axis2', 'HTTP_SC')">
                <then>
                    <log level="custom">
                        <property name="mylog" value="***************************** RECEIVED RESPONSE FROM: CREATE A NEW RESEARCH OBJECT **************************"/>
                        <property expression="$trp:Location" name="LOCATION"/>
                    </log>
                    <!--
                    	do the next invocation to the backend, if there is a "mode" field in the client request:
						2. Optional setting public/private visibility mode (access rights).
                    	Next invocations are performed in parallel taking advantage of backend computing power, while at the same time, in order to minimize user-perceived latency, the user will receive the response to her request using just the info from the response of the first invocation to the back end.

                    	So spawn a new execution thread for this invocation.

                    -->
                    <clone continueParent="true">
                        <target>
                            <sequence>
                                <filter xpath="$ctx:BODY_FOR_RESOURCES//mode">
                                    <then>
                                        <filter regex="PUBLIC" source="$ctx:BODY_FOR_RESOURCES//mode">
                                            <then/>
                                            <else>
                                                <log level="custom">
                                                    <property name="mylog" value="***************************** CALLING BACK END: SETTING ACCESS RIGHT **************************"/>
                                                    <property expression="$trp:Location" name="LOCATION"/>
                                                </log>
                                                <!--
                                                The url of the access control operation is http://sandbox.rohub.org/rodl/accesscontrol/modes/
                                                The request of the access control operation must be this (given the example client request):
                                                
                                                	POST /rodl/accesscontrol/modes/ HTTP/1.1
													Authorization: Bearer 7d6df5f8-6b5c-4d88-95e1-da101dcee6f8
													Content-Type: application/json
													Content-Length: 67
													Host: sandbox.rohub.org
													Connection: Keep-Alive
													User-Agent: Synapse-PT-HttpComponents-NIO
													
													{"ro":"http://sandbox.rohub.org/rodl/ROs/cde-20/","mode":"PRIVATE"}
													
													
													Please note that the value of the "ro" field in the body of the request must be the URI of the RO,
													and the value of the "mode" field must be equal to the value of the "mode" field in the client request.
                                                -->
                                                <!-- Synthesize the body of the request with this template in "format" and assign variables through "args" directive -->
                                                <payloadFactory media-type="json">
                                                    <format>
						    {"ro":"$1","mode":"$2"}
						</format>
                                                    <args>
                                                        <arg evaluator="xml" expression="get-property('RONAME')"/>
                                                        <arg evaluator="xml" expression="$ctx:BODY_FOR_RESOURCES//mode"/>
                                                    </args>
                                                </payloadFactory>
                                                <!-- disable default http-transfer method for synapse (Transfer-Encoding: chunked) -->
                                                <property name="DISABLE_CHUNKING" scope="axis2" type="STRING" value="true"/>
                                                <!-- set ContentType http header field to "application/json" -->
                                                <property name="messageType" scope="axis2" type="STRING" value="application/json"/>
                                                <!-- set Authorization http header field -->
                                                <property expression="get-property('AUTH')" name="Authorization" scope="transport" type="STRING"/>
                                                <!--  remaining http headers: Host, Connection, User-Agent, Content-Length are automatically set, so no more directive are needed. (Anyway they are not strictly needed by the back-end.) -->
                                                <!-- please note that two more http headers will be sent to the back-end:
                                                	Content-disposition: attachment; filename=".ro/manifest.rdf"
													Location: http://sandbox.rohub.org/rodl/ROs/cde-20/
													
												This is because they have not been deleted from the context and they are there from the first response from the back-end.
												Anyway, they are not dangerous, so no deletion is performed.
                                                 -->
                                                <!-- invoke the access control operation with the request just synthesized -->
                                                <call>
                                                    <endpoint>
                                                        <http uri-template="http://sandbox.rohub.org/rodl/accesscontrol/modes/"/>
                                                    </endpoint>
                                                </call>
                                            </else>
                                        </filter>
                                    </then>
                                    <else/>
                                </filter>
                                <drop/>
                            </sequence>
                        </target>
                    </clone>
                    <!--++
                        Let's call the RO API to annotate the just created RO with title and description (see REQUEST below), and let's reply to the client (see RESPONSE below).

						REQUEST
						
                    	I need to create a POST request to this url (This must be the url given by the value of "Location" http header in the response of the previous RO Creation call):
                    	
	                    	http://sandbox.wf4ever-project.org/rodl/ROs/OneMoreRo-14/
                    	
                    	with header parameters like these:
                    	 
	                        Authorization: Bearer 7d6df5f8-6b5c-4d88-95e1-da101dcee6f8
	                        Slug: title.rdf
							Link: <http://sandbox.wf4ever-project.org/rodl/ROs/OneMoreRo-14/>; rel="http://purl.org/ao/annotatesResource
                        
                        Please note that: OneMoreRo-14 is an example of ro name, and the Slug is an internal name at the moment not settable by the user and is always "title.rdf".
                        
                        The Payload of the POST request must be the rdf/xml representation of the body of the annotation.

		                    <rdf:RDF xmlns:roevo='http://purl.org/wf4ever/roevo#' xmlns:pavprov='http://purl.org/pav/provenance/2.0/' xmlns:ore-owl='http://purl.org/wf4ever/ore-owl' xmlns:ao='http://purl.org/ao/' xmlns:skos='http://www.w3.org/TR/skos-reference/skos-owl1-dl.rdf' xmlns:prov='http://www.w3.org/ns/prov#' xmlns:wfdesc='http://purl.org/wf4ever/wfdesc#' xmlns:pav='http://purl.org/pav/2.0/' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' xmlns:ro='http://purl.org/wf4ever/ro#' xmlns:roterms='http://purl.org/wf4ever/roterms#' xmlns:foaf='http://xmlns.com/foaf/0.1/' xmlns:wfprov='http://purl.org/wf4ever/wfprov#' xmlns:dct='http://purl.org/dc/terms/' xmlns:ore='http://www.openarchives.org/ore/terms/' xmlns:pavauth='http://purl.org/pav/authoring/2.0/' xmlns:wf4ever='http://purl.org/wf4ever/wf4ever#' xmlns:aocore='http://purl.org/ao/core/' >
			                    <rdf:Description rdf:about=''>
				                    <dct:title rdf:datatype='http://www.w3.org/2001/XMLSchema#string'>{ro_title}</dct:title>
				                    <dct:description rdf:datatype='http://www.w3.org/2001/XMLSchema#string'>{ro_desc}</dct:description>
			                    </rdf:Description>
			                </rdf:RDF>

                        Please note that it is possible to put both annotations (title and descritpion) in one rdf/xml resource, thas making it necessary to call the RO API jsut once instead of two.
						In addition note that it is not needed to specify the resource (in this case the RO) these annotations are bout, indeed rdf:about attribute is left empty.

						This is good because I do not know how to set xml attribute values in the next template instruction (but only xml element values using curly braces!)

						RESPONSE 
							It must be something like this:
						
							HTTP/1.1 201 Created
							
							Content-Type: application/json; charset=UTF-8
							Date: Sun, 13 Nov 2016 19:45:13 GMT
							Content-Length: 71
							
							{"ro_name":"http://sandbox.wf4ever-project.org/rodl/ROs/OneMoreRo-14/"}
					
						Please note that ro_name field value in the json body must be the url given by the value of the Location http header in the response of the previous call to the RO API for the annotation.
                     -->
                    <!-- spawn a separate thread to aggregate annotations (see below for the main thread) -->
                    <clone continueParent="true">
                        <target>
                            <sequence>
                                <log level="custom">
                                    <property name="mylog" value="***************************** ITERATING OVER INTERNAL RESOURCES **************************"/>
                                </log>
                                <!--
	                    		do the next set of invocations to the back-end:
	                    			3. Optional aggregation of internal resources
                                For all fields children of the "internal" field in the body of the client request, invoke the aggregation operation of the back-end.
                                Given the example client request, internal resources to be aggregated are 2, because 2 are the fields children of the "internal" field : {"myfolder/file1.txt": "MTIz"}, {"myfolder/file2.txt": "NDU2"}
                                For the first invocation of the aggregation operation, the http request to be synthesized is (for the other invocation it is analogous, only the Slug header and the body will be different):
                                	
                                	POST /rodl/ROs/cde-20/ HTTP/1.1
									Authorization: Bearer 7d6df5f8-6b5c-4d88-95e1-da101dcee6f8
									Slug: myfolder/file1.txt
									Content-Type: application/octet-stream
									Content-Length: 3
									Host: sandbox.rohub.org
									Connection: Keep-Alive
									User-Agent: Synapse-PT-HttpComponents-NIO
									
									123
									
								Please note that the value of the Slug header is given by the name of the "internal" child field corresponding to each step of the iteration
								Additionally, the body of the request is the content of the file to be aggregated.
								It must be got by base64-decoding the value of the "internal" child field corresponding to each step of the iteration.
								For example, for the first step of the iteration, the "internal" child field is "myfolder/file1.txt", whose value "MTIz", once decoded, gives "123".
                                -->
                                <iterate continueParent="true" expression="$ctx:BODY_FOR_RESOURCES//internal/*">
                                    <target>
                                        <sequence>
                                            <script language="js"><![CDATA[var fileName = mc.getEnvelope().getBody().getFirstElementLocalName();
												mc.setProperty("fileName", fileName);
												var fileContent = mc.getEnvelope().getBody().getFirstElement().getText();
							                    var decoded = new java.lang.String( org.apache.axiom.util.base64.Base64Utils.decode( fileContent));
							                    mc.setPayloadXML(
                                                    <ms11:text xmlns:ms11="http://ws.apache.org/commons/ns/payload">{decoded}</ms11:text>
							                    );]]></script>
                                            <!-- disable default http-transfer method for synapse (Transfer-Encoding: chunked) -->
                                            <property name="DISABLE_CHUNKING" scope="axis2" type="STRING" value="true"/>
                                            <property name="messageType" scope="axis2" type="STRING" value="text/plain"/>
                                            <!-- set http request header Content-Type: application/octet-stream -->
                                            <property name="ContentType" scope="axis2" type="STRING" value="application/octet-stream"/>
                                            <header name="Content-Type" scope="transport" value="application/octet-stream"/>
                                            <property name="Transfer-Encoding" scope="transport" type="STRING" value="base64"/>
                                            <!-- set http request header Slug to the filename got through the custom property filename set in the script directive above -->
                                            <property expression="get-property('fileName')" name="Slug" scope="transport" type="STRING"/>
                                            <!-- set the property uri.var.location to the url of the operation, to be used in the next "call" directive -->
                                            <property expression="get-property('LOCATION')" name="uri.var.location" scope="default" type="STRING"/>
                                            <!-- set http request header Authorization -->
                                            <property expression="get-property('AUTH')" name="Authorization" scope="transport" type="STRING"/>
                                            <!-- the other headers are set automatically: Content-Length, Host, Connection, User-Agent -->
                                            <!-- please note that two more http headers will be sent to the back-end:
                                                	Content-disposition: attachment; filename=".ro/manifest.rdf"
													Location: http://sandbox.rohub.org/rodl/ROs/cde-20/
													
												This is because they have not been deleted from the context and they are there from the first response from the back-end.
												Anyway, they are not dangerous, so no deletion is performed.
                                            -->
                                            <log level="custom">
                                                <property name="mylog" value="***************************** CALLING BACK END: AGGREGATE INTERNAL RESOURCE **************************"/>
                                            </log>
                                            <call>
                                                <endpoint>
                                                    <http uri-template="{uri.var.location}"/>
                                                </endpoint>
                                            </call>
                                            <!--
                                            	Terminate here this message flow and discard the response, because it is of no use. (Possibly the response should be analyzed to handle errors)
                                            -->
                                            <drop/>
                                        </sequence>
                                    </target>
                                    <!-- after this "iterate" directive due to xPath expression terminating in "*" the root-->
                                </iterate>
                                <log level="custom">
                                    <property name="mylog" value="***************************** ITERATING OVER EXTERNAL RESOURCES **************************"/>
                                </log>
                                <!--
	                    		do the next set of invocations to the back-end:
	                    			4. Optional aggregation of external resources
                                For all items in the "external" field in the body of the client request, invoke the aggregation operation of the back-end.
                                Given the example client request, external resources to be aggregated are 2, because 2 are the items in the "external" field : ["http://sdeg.com/resource1.html", "https://sdeg.it/res2.do"]
                                For the first invocation of the aggregation operation, the http request to be synthesized is (for the other invocation it is analogous, only the attribute rdf:resource in the xml body must be set accordingly):
                                	
									POST /rodl/ROs/cde-20/ HTTP/1.1
									Authorization: Bearer 7d6df5f8-6b5c-4d88-95e1-da101dcee6f8
									Content-Type: application/vnd.wf4ever.proxy
									Content-Length: 222
									Host: sandbox.rohub.org
									Connection: Keep-Alive
									User-Agent: Synapse-PT-HttpComponents-NIO
									
									<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:ore="http://www.openarchives.org/ore/terms/">
									  <ore:Proxy>
									    <ore:proxyFor rdf:resource="http://sdeg.com/resource1.html"/>
									  </ore:Proxy>
									</rdf:RDF>
									
								Please note that the value of the rdf:resource attribute in the xml body is given by the name of the "external" array item corresponding to each step of the iteration
								For example, for the first step of the iteration, the "external" array item is "http://sdeg.com/resource1.html".
 
                                -->
                                <iterate continueParent="true" expression="$ctx:BODY_FOR_RESOURCES//external">
                                    <target>
                                        <sequence>
                                            <script language="js"><![CDATA[var uri = mc.getEnvelope().getBody().getFirstElement().getText();
												var proxy = <rdf:RDF xmlns:ore='http://www.openarchives.org/ore/terms/' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'> <ore:Proxy> <ore:proxyFor rdf:resource={uri}/> </ore:Proxy> </rdf:RDF>;
							                    mc.setPayloadXML( proxy);]]></script>
                                            <!-- disable default http-transfer method for synapse (Transfer-Encoding: chunked) -->
                                            <property name="DISABLE_CHUNKING" scope="axis2" type="STRING" value="true"/>
                                            <property name="messageType" scope="axis2" type="STRING" value="application/xml"/>
                                            <!-- set http request header Content-Type: application/vnd.wf4ever.proxy -->
                                            <property name="ContentType" scope="axis2" type="STRING" value="application/vnd.wf4ever.proxy"/>
                                            <header name="Content-Type" scope="transport" value="application/vnd.wf4ever.proxy"/>
                                            <property expression="get-property('LOCATION')" name="uri.var.location" scope="default" type="STRING"/>
                                            <property expression="get-property('AUTH')" name="Authorization" scope="transport" type="STRING"/>
                                            <!-- the other headers are set automatically: Content-Length, Host, Connection, User-Agent -->
                                            <!-- please note that two more http headers will be sent to the back-end:
                                                	Content-disposition: attachment; filename=".ro/manifest.rdf"
													Location: http://sandbox.rohub.org/rodl/ROs/cde-20/
													
												This is because they have not been deleted from the context and they are there from the first response from the back-end.
												Anyway, they are not dangerous, so no deletion is performed.
                                            -->
                                            <log level="custom">
                                                <property name="mylog" value="***************************** CALLING BACK END: AGGREGATE EXTERNAL RESOURCE **************************"/>
                                            </log>
                                            <call>
                                                <endpoint>
                                                    <http uri-template="{uri.var.location}"/>
                                                </endpoint>
                                            </call>
                                            <!--
                                            	Terminate here this message flow and discard the response, because it is of no use. (Possibly the response should be analyzed to handle errors)
                                            -->
                                            <drop/>
                                        </sequence>
                                    </target>
                                </iterate>
                                <!--
	                                do the next set of invocations to the back-end:
                    					5. Annotate the RO with the title, description, and VRC

                                
	                                Authorization: Bearer 7d6df5f8-6b5c-4d88-95e1-da101dcee6f8
									Slug: title.rdf
									Link: <http://sandbox.rohub.org/rodl/ROs/cde-20/>; rel="http://purl.org/ao/annotatesResource"
									Content-Type: application/xml
									Transfer-Encoding: chunked
									Host: sandbox.rohub.org
									Connection: Keep-Alive
									User-Agent: Synapse-PT-HttpComponents-NIO
									
									4c9
									<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:pavauth="http://purl.org/pav/authoring/2.0/" xmlns:ore="http://www.openarchives.org/ore/terms/" xmlns:wf4ever="http://purl.org/wf4ever/wf4ever#" xmlns:pav="http://purl.org/pav/2.0/" xmlns:roterms="http://purl.org/wf4ever/roterms#" xmlns:skos="http://www.w3.org/TR/skos-reference/skos-owl1-dl.rdf" xmlns:ao="http://purl.org/ao/" xmlns:acs="http://www.acsys.it/everest#" xmlns:dct="http://purl.org/dc/terms/" xmlns:ore-owl="http://purl.org/wf4ever/ore-owl" xmlns:wfprov="http://purl.org/wf4ever/wfprov#" xmlns:roevo="http://purl.org/wf4ever/roevo#" xmlns:aocore="http://purl.org/ao/core/" xmlns:pavprov="http://purl.org/pav/provenance/2.0/" xmlns:prov="http://www.w3.org/ns/prov#" xmlns:ro="http://purl.org/wf4ever/ro#" xmlns:wfdesc="http://purl.org/wf4ever/wfdesc#" xmlns:foaf="http://xmlns.com/foaf/0.1/">
									  <rdf:Description rdf:about="">
									    <dct:title rdf:datatype="http://www.w3.org/2001/XMLSchema#string">The Title</dct:title>
									    <dct:description rdf:datatype="http://www.w3.org/2001/XMLSchema#string">The Description</dct:description>
									    <acs:vrc rdf:datatype="http://www.w3.org/2001/XMLSchema#string">CNR</acs:vrc>
									  </rdf:Description>
									</rdf:RDF>
									0
								
								Please note that the Slug header has been set to "title.rdf" and this value is embedded in the next block of directive. Its value is not important, it can be whatever.                                
                                -->
                                <!-- 
                                    create the rdf xml for the title, the description and the VRC that will be aggregated to the RO as an annotation
                                	from the former request body, values of ro_title, ro_desc and ro_vrc fields are read into an rdf xml template
                                 -->
                                <!-- (WSO2ESB) Note that I can still read the PayloadJSON from the mc even though with the previous access to the mc I deleted the payloadXML-->
                                <script language="js"><![CDATA[var ro_title = mc.getPayloadJSON().ro_title.toString();
				                    var ro_desc = mc.getPayloadJSON().ro_desc.toString();
				                    var ro_vrc = mc.getPayloadJSON().ro_vrc.toString();
				                    var ro_name = mc.getProperty('RONAME');
				                    mc.setPayloadXML(
				                    	<rdf:RDF xmlns:acs="http://www.acsys.it/everest#" xmlns:roevo='http://purl.org/wf4ever/roevo#' xmlns:pavprov='http://purl.org/pav/provenance/2.0/' xmlns:ore-owl='http://purl.org/wf4ever/ore-owl' xmlns:ao='http://purl.org/ao/' xmlns:skos='http://www.w3.org/TR/skos-reference/skos-owl1-dl.rdf' xmlns:prov='http://www.w3.org/ns/prov#' xmlns:wfdesc='http://purl.org/wf4ever/wfdesc#' xmlns:pav='http://purl.org/pav/2.0/' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' xmlns:ro='http://purl.org/wf4ever/ro#' xmlns:roterms='http://purl.org/wf4ever/roterms#' xmlns:foaf='http://xmlns.com/foaf/0.1/' xmlns:wfprov='http://purl.org/wf4ever/wfprov#' xmlns:dct='http://purl.org/dc/terms/' xmlns:ore='http://www.openarchives.org/ore/terms/' xmlns:pavauth='http://purl.org/pav/authoring/2.0/' xmlns:wf4ever='http://purl.org/wf4ever/wf4ever#' xmlns:aocore='http://purl.org/ao/core/' > <rdf:Description rdf:about=''> <dct:title rdf:datatype='http://www.w3.org/2001/XMLSchema#string'>{ro_title}</dct:title> <dct:description rdf:datatype='http://www.w3.org/2001/XMLSchema#string'>{ro_desc}</dct:description> <acs:vrc rdf:datatype='http://www.w3.org/2001/XMLSchema#string'>{ro_vrc}</acs:vrc>  </rdf:Description> </rdf:RDF>
				                    );]]></script>
                                <log level="custom">
                                    <property name="mylog" value="***************************** ANNOTATION RDFXML rendered **************************"/>
                                </log>
                                <!-- remove Location header coming from previous response -->
                                <property action="remove" name="Location" scope="transport"/>
                                <!-- choose the xml formatter -->
                                <property name="messageType" scope="axis2" type="STRING" value="application/xml"/>
                                <!-- set headers -->
                                <property name="Content-Type" scope="transport" type="STRING" value="application/rdf+xml"/>
                                <property name="Slug" scope="transport" type="STRING" value="title.rdf"/>
                                <property expression="get-property('AUTH')" name="Authorization" scope="transport" type="STRING"/>
                                <property expression="fn:concat('&lt;', get-property('RONAME'), '>; rel=&quot;http://purl.org/ao/annotatesResource&quot;')" name="Link" scope="transport" type="STRING"/>
                                <!-- the other headers are set automatically: Transfer-Encoding, Host, Connection, User-Agent -->
                                <!-- please note that one more http header will be sent to the back-end:
                                               	Content-disposition: attachment; filename=".ro/manifest.rdf"
												
									This is because it has not been deleted from the context and it is there from the first response from the back-end.
									Anyway, it is not dangerous, so no deletion is performed.
                                -->
                                <log level="custom">
                                    <property name="mylog" value="*********************** CALLING BACK END: AGGREGATE ANNOTATIONS ********************"/>
                                    <property expression="get-property('transport', 'Link')" name="TheLink"/>
                                </log>
                                <!-- call the annotation operation on the ro api -->
                                <property expression="get-property('LOCATION')" name="uri.var.location" scope="default" type="STRING"/>
                                <call>
                                    <endpoint>
                                        <http uri-template="{uri.var.location}"/>
                                    </endpoint>
                                </call>
                                <!--
                                	Terminate here this message flow and discard the response, because it is of no use. (Possibly the response should be analyzed to handle errors)
                                -->
                                <drop/>
                            </sequence>
                        </target>
                    </clone>
                    <!-- main thread replying to the client without waiting for the response by the aggregation call -->
                    <!-- no http header must be set explicitly. Those coming from the response of the preceding call must be removed -->
                    <!-- (WSO2ESB) There is no way to delete multiple headers with the same field name, indeed one is left from the previous response from roAPI to the next to the client: Link: <http://sandbox.wf4ever-project.org/rodl/ROs/OneMoreRo-14/>; rel="http://purl.org/ao/annotatesResource"-->
                    <property action="remove" name="TRANSPORT_HEADERS" scope="axis2"/>
                    <!-- next directive is to avoid using Transfer-Encoding: chunked -->
                    <property name="DISABLE_CHUNKING" scope="axis2" type="STRING" value="true"/>
                    <!-- set the json payload -->
                    <payloadFactory media-type="json">
                        <format>{"ro_name":"$1"}</format>
                        <args>
                            <arg evaluator="xml" expression="get-property('RONAME')"/>
                        </args>
                    </payloadFactory>
                    <property name="messageType" scope="axis2" type="STRING" value="application/json"/>
                    <log level="custom">
                        <property name="mylog" value="*********************** REPLYING TO THE CLIENT ********************"/>
                    </log>
                    <respond/>
                </then>
                <else>
                    <log level="full"/>
                    <log level="custom">
                        <property expression="get-property('axis2', 'HTTP_SC')" name="STATUS_CODE"/>
                    </log>
                    <respond/>
                </else>
            </filter>
        </inSequence>
        <outSequence/>
        <faultSequence/>
    </resource>
    <resource methods="POST" url-mapping="/">
        <inSequence>
            <enrich>
                <source clone="true" type="body"/>
                <target property="BODY" type="property"/>
            </enrich>
            <iterate continueParent="true" expression="$ctx:BODY//ROs">
                <target>
                    <sequence>
                        <script language="js"><![CDATA[//
							var ro = mc.getEnvelope().getBody().getFirstElement().getText();
							mc.setProperty("RO", ro);
							//]]></script>
                        <property expression="get-property('RO')" name="uri.var.ro" scope="default" type="STRING"/>
                        <call>
                            <endpoint>
                                <http method="delete" uri-template="{uri.var.ro}"/>
                            </endpoint>
                        </call>
                    </sequence>
                </target>
            </iterate>
            <property action="remove" name="TRANSPORT_HEADERS" scope="axis2"/>
            <property name="HTTP_SC" scope="axis2" type="STRING" value="204"/>
            <respond/>
        </inSequence>
        <outSequence/>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
            <send/>
        </faultSequence>
    </resource>
    <resource methods="POST" url-mapping="/sparql">
        <inSequence>
            <log level="custom">
                <property name="mylog" value="***************************** RECEIVED REQUEST FROM THE CLIENT **************************"/>
            </log>
            <!-- choose the xml formatter -->
            <property name="messageType" scope="axis2" type="STRING" value="application/x-www-form-urlencoded"/>
            <!-- set headers -->
            <property name="Content-Type" scope="transport" type="STRING" value="application/x-www-form-urlencoded"/>
            <property name="Accept" scope="transport" type="STRING" value="application/sparql-results+json"/>
            <log level="custom">
                <property name="mylog" value="*********************** CALLING BACK END: SPARQL ********************"/>
            </log>
            <!-- call the annotation operation on the ro api -->
            <property expression="get-property('RONAME')" name="uri.var.location" scope="default" type="STRING"/>
            <script language="js"><![CDATA[//
            	var payloadJSON = mc.getPayloadJSON();
				var entityType = "";
				if( 'entityType' in payloadJSON){
					entityType = payloadJSON.entityType;
				}
				var query = "";
				if( entityType === "resource"){
					var ro = "";
					if( 'ro' in payloadJSON){
						ro = payloadJSON.ro;
					}
					var orderBy = "ORDER BY ?created ?resource ?creator ?type";
					if( 'orderBy' in payloadJSON){
						orderBy = "ORDER BY " + payloadJSON.orderBy;
					}
					query = "\
						PREFIX ore: <http://www.openarchives.org/ore/terms/>\
						PREFIX  ao:    <http://purl.org/ao/>\
						PREFIX dct: <http://purl.org/dc/terms/>\
						PREFIX ro: <http://purl.org/wf4ever/ro#>\
						SELECT ?resource ?creator ?created ?name ?filesize ?type ?proxy\
						WHERE {\
						<" + ro + "> ore:isDescribedBy ?graph ;\
									 ore:aggregates ?resource .\
						OPTIONAL { ?resource ro:name ?name}\
						OPTIONAL { ?resource ro:filesize ?filesize}\
						OPTIONAL { ?resource a ?type\
						FILTER ( ?type != ore:AggregatedResource)\
						FILTER ( ?type != ro:Resource)\
						}\
						GRAPH ?graph{\
							?resource a ro:Resource .\
							OPTIONAL { ?resource dct:creator ?creator}\
							OPTIONAL { ?resource dct:created ?created}\
							?proxy ore:proxyFor ?resource\
							} \
						} " + orderBy + "\
					";
				}else{
					var vrc = "";
					if( 'vrc' in payloadJSON){
						vrc = "FILTER regex( str( ?vrc), \"" + payloadJSON.vrc + "\", \"i\") ";
					}
	            	var createdInterval = "";
					if( 'since_YYYY-MM-DD' in payloadJSON){
		            	createdInterval += "\
						    FILTER ( ?created >= \"" + payloadJSON["since_YYYY-MM-DD"] + "T00:00:00.000Z\"^^xsd:dateTime) \
						";
					}
					if( 'till_YYYY-MM-DD' in payloadJSON){
		            	createdInterval += "\
						    FILTER ( ?created >= \"" + payloadJSON["since_YYYY-MM-DD"] + "T00:00:00.000Z\"^^xsd:dateTime) \
						";
					}
					var title = "";
					if( 'title' in payloadJSON){
						title = "FILTER regex( str( ?title), \"" + payloadJSON.title + "\", \"i\")";
					}
					var description = "";
					if( 'description' in payloadJSON){
						description = "FILTER regex( str( ?description), \"" + payloadJSON.description + "\", \"i\")";
					}
					var creator = "";
					if( 'creator' in payloadJSON){
						creator = "FILTER regex( str( ?creator), \"" + payloadJSON.creator + "\", \"i\")";
					}
					var status = "";
					if( 'status' in payloadJSON){
						status = "FILTER EXISTS{ ?ro a roevo:" + payloadJSON.status + "}";
					}
					var ro = "";
					if( 'ro' in payloadJSON){
						ro = "FILTER regex( str( ?ro), \"" + payloadJSON.ro + "\", \"i\")";
					}
					var orderBy = "ORDER BY ?title ?created ?creator ?ro ?description ?vrc ?status";
					if( 'orderBy' in payloadJSON){
						orderBy = "ORDER BY " + payloadJSON.orderBy;
					}
					query = "\
					PREFIX dct: <http://purl.org/dc/terms/>\
					PREFIX dcterms: <http://purl.org/dc/terms/>\
					PREFIX ro: <http://purl.org/wf4ever/ro#>\
					PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\
					PREFIX acs: <http://www.acsys.it/everest#>\
					PREFIX roevo: <http://purl.org/wf4ever/roevo#>\
					PREFIX foaf: <http://xmlns.com/foaf/0.1/>\
					SELECT ?ro ?created ?title ?description ?vrc ?creatorName ?creator (IF(EXISTS{ ?ro a roevo:LiveRO}, \"LiveRO\", IF( EXISTS{ ?ro a roevo:SnapshotRO}, \"SnapshotRO\", \"ArchivedRO\")) as ?status)\
					WHERE { \
					 	?ro a ro:ResearchObject .\
					    OPTIONAL { ?ro acs:vrc ?vrc } .\
					    OPTIONAL { ?ro dct:created ?created } .\
						OPTIONAL { ?ro dct:title ?title } .\
						OPTIONAL { ?ro dct:description ?description } .\
						OPTIONAL { ?ro dcterms:creator ?creator .\
						OPTIONAL { ?creator foaf:name ?creatorName . } }\
						" + vrc
						+ createdInterval
						+ title
						+ description
						+ creator
						+ status
						+ ro
					+ " } " + orderBy
					;
					// FILTER regex( str( ?x), \"Pack\")\
				}
				mc.setProperty("QUERY", query);
				mc.setPayloadXML( <params xmlns=""><query>{query}</query></params>);
			//]]></script>
            <log level="custom">
                <property expression="get-property('QUERY')" name="SPARQL QUERY:"/>
            </log>
            <call>
                <endpoint>
                    <http uri-template="http://sandbox.rohub.org/rodl/"/>
                </endpoint>
            </call>
            <respond/>
        </inSequence>
        <outSequence/>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
        </faultSequence>
    </resource>
    <resource methods="POST" url-mapping="/evo/copy">
        <inSequence>
            <call>
                <endpoint>
                    <http uri-template="http://sandbox.rohub.org/rodl"/>
                </endpoint>
            </call>
            <respond/>
        </inSequence>
        <outSequence/>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
            <send/>
        </faultSequence>
    </resource>
    <resource url-mapping="/add">
        <inSequence>
            <property expression="$body//ro" name="uri.var.location" scope="default" type="STRING"/>
            <clone continueParent="true">
                <target>
                    <sequence>
                        <iterate continueParent="true" expression="$body//internal/*">
                            <target>
                                <sequence>
                                    <script language="js"><![CDATA[var fileName = mc.getEnvelope().getBody().getFirstElementLocalName();
							mc.setProperty("fileName", fileName);
							var fileContent = mc.getEnvelope().getBody().getFirstElement().getText();
							var decoded = new java.lang.String( org.apache.axiom.util.base64.Base64Utils.decode( fileContent));
							mc.setPayloadXML(
                                        <ms11:text xmlns:ms11="http://ws.apache.org/commons/ns/payload">{decoded}</ms11:text>
						);]]></script>
                                    <property name="DISABLE_CHUNKING" scope="axis2" type="STRING" value="true"/>
                                    <property name="messageType" scope="axis2" type="STRING" value="text/plain"/>
                                    <property name="ContentType" scope="axis2" type="STRING" value="application/octet-stream"/>
                                    <header name="Content-Type" scope="transport" value="application/octet-stream"/>
                                    <property name="Transfer-Encoding" scope="transport" type="STRING" value="base64"/>
                                    <property expression="get-property('fileName')" name="Slug" scope="transport" type="STRING"/>
                                    <property expression="$trp:Authorization" name="Authorization" scope="transport" type="STRING"/>
                                    <property action="remove" name="REST_URL_POSTFIX" scope="axis2"/>
                                    <log level="custom">
                                        <property name="mylog" value="***************************** CALLING BACK END: AGGREGATE INTERNAL RESOURCE **************************"/>
                                        <property expression="get-property('uri.var.location')" name="mylog"/>
                                    </log>
                                    <call>
                                        <endpoint>
                                            <http uri-template="{uri.var.location}"/>
                                        </endpoint>
                                    </call>
                                    <drop/>
                                </sequence>
                            </target>
                        </iterate>
                    </sequence>
                </target>
                <target>
                    <sequence>
                        <iterate continueParent="true" expression="$body//external">
                            <target>
                                <sequence>
                                    <script language="js"><![CDATA[var uri = mc.getEnvelope().getBody().getFirstElement().getText();
												var proxy = <rdf:RDF xmlns:ore='http://www.openarchives.org/ore/terms/' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'> <ore:Proxy> <ore:proxyFor rdf:resource={uri}/> </ore:Proxy> </rdf:RDF>;
							                    mc.setPayloadXML( proxy);]]></script>
                                    <property name="DISABLE_CHUNKING" scope="axis2" type="STRING" value="true"/>
                                    <property name="messageType" scope="axis2" type="STRING" value="application/xml"/>
                                    <property name="ContentType" scope="axis2" type="STRING" value="application/vnd.wf4ever.proxy"/>
                                    <header name="Content-Type" scope="transport" value="application/vnd.wf4ever.proxy"/>
                                    <property expression="$trp:Authorization" name="Authorization" scope="transport" type="STRING"/>
                                    <property action="remove" name="REST_URL_POSTFIX" scope="axis2"/>
                                    <log level="custom">
                                        <property name="mylog" value="***************************** CALLING BACK END: AGGREGATE EXTERNAL RESOURCE **************************"/>
                                    </log>
                                    <call>
                                        <endpoint>
                                            <http uri-template="{uri.var.location}"/>
                                        </endpoint>
                                    </call>
                                    <drop/>
                                </sequence>
                            </target>
                        </iterate>
                    </sequence>
                </target>
            </clone>
        </inSequence>
        <outSequence>
            <!--  -->
        </outSequence>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
        </faultSequence>
    </resource>
    <resource methods="POST" url-mapping="/second">
        <inSequence>
            <script language="js"><![CDATA[//
							mc.setProperty("myProp", "myValue");
							var keySetSize = mc.getPropertyKeySet().size();
							var it = mc.getPropertyKeySet().iterator();
							java.lang.System.out.println( "***************");
							var keySet = '';
							for( var i = 0; i < keySetSize; i++){
								var key = it.next();
								var value = mc.getProperty( key);
								java.lang.System.out.println( key + " = " + value);
							}
							mc.setProperty("keySet", keySet);
							var context = mc.getContextEntries().entrySet();
							for( var i = 0; i < context.size(); i++){
								var next = context.iterator().next();
								java.lang.System.out.println( next.getKey() + " = " + next.getValue());
							}
//							"http://www.w3.org/2003/05/soap-envelope";
							var path = org.apache.synapse.util.xpath.SynapseXPath.parseXPathString("//*");
							var iter = path.selectNodes( mc).listIterator();
							var navigator = path.getNavigator();
//							java.lang.System.out.println( "iter.hasNext() = " + iter.hasNext());
							for( ; iter.hasNext(); ){
								var next = iter.next();
								var name = navigator.getElementName( next);
								var qName = navigator.getElementQName( next);
								var namespaceUri = navigator.getElementNamespaceUri( next);
								var stringValue = navigator.getElementStringValue( next);
								java.lang.System.out.println( "name = " + name + "; " + "qName = " + qName + "; " + "namespaceUri = " + namespaceUri + "; " + "stringValue = " + stringValue);
							}
							var tree = path.debug();
							java.lang.System.out.println( "tree = " + tree);
//							var sysDate = path.stringValueOf( mc);
//							java.lang.System.out.println( "sysDate = " + sysDate);
							var trpUri = path.getNamespaceContext().translateNamespacePrefixToUri("trp");
							java.lang.System.out.println( "trpUri = " + trpUri);
							var path2 = org.apache.synapse.util.xpath.SynapseXPath.parseXPathString("namespace-uri(/*)");
							var uri = path2.stringValueOf( mc);
							java.lang.System.out.println( "uri = " + uri);
			//]]></script>
            <log level="full">
                <property expression="$trp:Content-Length" name="Content-Length"/>
                <property expression="get-property('$trp:Content-Length')" name="GetPropertyContent-Length"/>
                <property expression="get-property('keySet')" name="keySet"/>
                <property expression="namespace-uri( $ctx:body)" name="URI"/>
            </log>
        </inSequence>
        <outSequence/>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
        </faultSequence>
    </resource>
    <resource methods="POST" url-mapping="/upload">
        <inSequence>
            <property name="DISABLE_CHUNKING" scope="axis2" type="STRING" value="true"/>
            <log level="custom">
                <property name="banner" value="XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"/>
            </log>
            <!--            <log level="full"/>
            <enrich>
                <source clone="true" type="body"/>
                <target property="body" type="property"/>
            </enrich>
            <log level="custom">
                <property expression="get-property('body')" name="TheBody"/>
            </log>
-->
            <!-- property name="messageType" scope="axis2" type="STRING" value="multipart/form-data"/>  -->
            <!-- property name="messageType" scope="axis2" type="STRING" value="multipart/related"/>
            <property name="ContentType" scope="axis2" type="STRING" value="multipart/related"/> -->
            <send>
                <endpoint>
                    <http uri-template="http://localhost:8123/"/>
                </endpoint>
            </send>
        </inSequence>
        <outSequence>
            <log level="custom">
                <property name="banner" value="YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"/>
            </log>
            <log level="full"/>
            <send/>
        </outSequence>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
        </faultSequence>
    </resource>
    <resource methods="POST" url-mapping="/prova">
        <inSequence>
            <property name="messageType" scope="axis2" type="STRING" value="application/xml"/>
            <script language="js"><![CDATA[mc.setProperty( "MYPAYLOADXML", mc.getPayloadXML());
            	mc.setProperty( "MYPAYLOADSOAP", mc.getEnvelopeXML());]]></script>
            <log level="custom">
                <property expression="json-eval($.)" name="mylog"/>
                <property expression="get-property('MYPAYLOADXML')" name="MYPAYLOADXML"/>
                <property expression="get-property('MYPAYLOADSOAP')" name="MYPAYLOADSOAP"/>
            </log>
            <property name="messageType" scope="axis2" type="STRING" value="application/json"/>
            <script language="js"><![CDATA[mc.setProperty( "MYPAYLOADJSON", mc.getPayloadJSON());]]></script>
            <log level="custom">
                <property expression="get-property('MYPAYLOADJSON')" name="MYPAYLOADJSON"/>
            </log>
            <respond/>
        </inSequence>
        <outSequence/>
        <faultSequence/>
    </resource>
    <resource methods="GET" url-mapping="/">
        <inSequence>
            <log level="custom">
                <property name="banner" value="XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"/>
            </log>
            <property name="HTTP_METHOD" scope="axis2" type="STRING" value="POST"/>
            <header name="Content-Length" scope="transport" value="0"/>
            <header name="Accept" scope="transport" value="image/jpeg"/>
            <property name="DISABLE_CHUNKING" scope="axis2" type="STRING" value="true"/>
            <call blocking="true">
                <endpoint>
                    <http uri-template="http://www.google.it/"/>
                </endpoint>
            </call>
            <respond/>
        </inSequence>
        <outSequence>
            <log level="custom">
                <property name="banner" value="YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"/>
            </log>
            <log level="full"/>
            <property name="messageType" scope="axis2" type="STRING" value="text/plain"/>
            <send/>
        </outSequence>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
        </faultSequence>
    </resource>
    <resource methods="POST" url-mapping="/json">
        <inSequence>
            <log level="custom">
                <property expression="get-property('JSON_STRING')" name="JSON_STRING"/>
            </log>
            <log level="custom">
                <property expression="$ctx:JSON_STRING" name="JSON_STRING_ctx"/>
            </log>
            <!-- log level="custom">
                <property expression="json-eval($.)" name="json-eval($.)"/>
            </log>
            <log level="custom">
                <property expression="$ctx:body" name="$ctx:body"/>
            </log>
            <property name="messageType" scope="axis2" type="STRING" value="application/xml"/>
            <log level="custom">
                <property expression="$ctx:body" name="$ctx:body"/>
            </log>
            <script language="js"><![CDATA[mc.setProperty('mybody',mc.getEnvelope().getBody());]]></script>
            <log level="custom">
                <property name="banner" value="YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"/>
                <property expression="get-property( 'mybody')" name="asd"/>
            </log>
            <script language="js"><![CDATA[mc.getEnvelope().getBody().getFirstElement().detach();]]></script>
              -->
            <property name="FORCE_POST_PUT_NOBODY" scope="axis2" type="BOOLEAN" value="true"/>
            <payloadFactory media-type="xml">
                <format>
                    <jsonObject>
                        <a>1</a>
                    </jsonObject>
                </format>
                <args/>
            </payloadFactory>
            <log level="custom">
                <property expression="json-eval($.)" name="json-eval_before"/>
            </log>
            <script language="js"><![CDATA[mc.setProperty('localName', mc.getEnvelope().getBody().getFirstElementLocalName());]]></script>
            <log level="custom">
                <property expression="$ctx:localName" name="LOCAL_NAME"/>
            </log>
            <script language="js"><![CDATA[mc.getEnvelope().getBody().getFirstElement().detach();]]></script>
            <property name="FORCE_POST_PUT_NOBODY" scope="axis2" type="BOOLEAN" value="true"/>
            <!-- property action="remove" name="NO_ENTITY_BODY" scope="axis2"/>  -->
            <call>
                <endpoint>
                    <http uri-template="http://localhost:8123/"/>
                </endpoint>
            </call>
            <log level="custom">
                <property expression="json-eval($.)" name="json-eval_after"/>
            </log>
            <property name="messageType" scope="axis2" type="STRING" value="application/json"/>
            <!-- script language="js"><![CDATA[mc.setProperty('mybody_json',mc.getPayloadJSON()..text.toString());]]></script> -->
            <log level="custom">
                <property name="banner" value="XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"/>
                <property expression="get-property( 'mybody')" name="asd"/>
                <property expression="get-property( 'JSON_STREAM')" name="zxc"/>
            </log>
            <respond/>
        </inSequence>
        <outSequence/>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
        </faultSequence>
    </resource>
    <resource methods="POST" url-mapping="/wiretap">
        <inSequence>
            <clone continueParent="true">
                <target>
                    <sequence>
                        <log level="custom">
                            <property expression="$ctx:body" name="banner"/>
                        </log>
                        <call>
                            <endpoint>
                                <http uri-template="http://localhost:8123/wiretapped"/>
                            </endpoint>
                        </call>
                    </sequence>
                </target>
            </clone>
            <call>
                <endpoint>
                    <http uri-template="http://localhost:8123/main"/>
                </endpoint>
            </call>
            <respond/>
        </inSequence>
        <outSequence/>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
        </faultSequence>
    </resource>
    <resource methods="POST" url-mapping="/plain">
        <inSequence>
            <payloadFactory media-type="xml">
                <format>
                    <ms11:text xmlns:ms11="http://ws.apache.org/commons/ns/payload">MTIz</ms11:text>
                </format>
                <args/>
            </payloadFactory>
            <property name="messageType" scope="axis2" type="STRING" value="application/octet-stream"/>
            <call>
                <endpoint>
                    <http uri-template="http://localhost:8123/"/>
                </endpoint>
            </call>
            <respond/>
        </inSequence>
        <outSequence/>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
        </faultSequence>
    </resource>
    <resource methods="POST" url-mapping="/iterate">
        <inSequence>
            <iterate expression="//internal/*">
                <target>
                    <sequence>
                        <script language="js"><![CDATA[var elementName = mc.getEnvelope().getBody().getFirstElementLocalName();
        				mc.setProperty( "elementName", elementName);]]></script>
                        <log level="custom">
                            <property expression="get-property('elementName')" name="--------------------"/>
                        </log>
                    </sequence>
                </target>
            </iterate>
            <respond/>
        </inSequence>
        <outSequence/>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
        </faultSequence>
    </resource>
    <resource methods="POST" url-mapping="/filter">
        <inSequence>
            <filter regex="ok" source="json-eval($.ro_vrc)">
                <then>
                    <log level="custom">
                        <property name="OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO" value="OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO"/>
                    </log>
                </then>
                <else/>
            </filter>
            <respond/>
        </inSequence>
        <outSequence/>
        <faultSequence>
            <log level="full">
                <property name="MESSAGE" value="Executing default sequence"/>
                <property expression="get-property('ERROR_CODE')" name="ERROR_CODE"/>
                <property expression="get-property('ERROR_MESSAGE')" name="ERROR_MESSAGE"/>
            </log>
        </faultSequence>
    </resource>
</api>
